{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/JavaScript/const_let_var/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p>이 포스트는 <a href=\"https://www.inflearn.com/course/%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/dashboard\" target=\"_blank\" rel=\"nofollow\">이재승님의 실전 자바스크립트</a> 의 강의와 책 내용을 정리하기 위해 작성된 글 입니다.</p>\n<h2>변수를 정의하는 새로운 방법: const, let</h2>\n<p>ES5까지의 자바스크립트에서는 var를 이용해서 변수를 정의했고 그게 유일한 방법이었습니다.<br>\r\nES6에서는 const, let을 이용하는 새로운 변수 정의 방법이 생겼습니다.<br>\r\n새로운 방법이 나온 이유는 기존 방식인 var로는 해결되지 않는 문제가 있었기 때문입니다.</p>\n<h3>var가 가진 문제</h3>\n<h4>var의 문제 1. 함수 스코프</h4>\n<p>var의 첫 번째 문제는 정의된 변수가 함수 스코프를 가진다는 것입니다.</p>\n<blockquote>\n<p>스코프(scope)란?<br>\r\n변수가 사용될 수 있는 영역을 말합니다.<br>\r\n스코프는 변수가 정의된 위치에 의해 결정됩니다.<br></p>\n</blockquote>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Glossary/Scope\" target=\"_blank\" rel=\"nofollow\">https://developer.mozilla.org/ko/docs/Glossary/Scope</a></p>\n<p>var는 함수 스코프이기 때문에 <code class=\"language-text\">코드 1</code>과 같이 함수를 벗어난 영역에서 사용하면 에러가 발생합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 코드 1 - 스코프를 벗어나서 변수를 사용하면 에러 발생</span>\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">example</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 참조 에러</span></code></pre></div>\n<p>실행 결과</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">console.log<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // 참조 에러\r\n            ^\r\nReferenceError: i is not defined</code></pre></div>\n<p>var 변수를 함수가 아닌 프로그램의 가장 바깥에서 정의하면 전역변수가 되며, 특이한 점은 함수 안에서 var 키워드를 사용하지 않고 변수에 값을 할당하면 그 변수는 전역 변수가 된다는 점입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 코드 2 - var 키워드 없이 변수를 정의하면 전역 변수가 됩니다.</span>\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">example1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">exapmle2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n<span class=\"token function\">example1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token function\">example2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1</span></code></pre></div>\n<p>실행 결과</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token number\">1</span></code></pre></div>\n<p>이런 상황에서 명시적 에러가 발생하도록 하려면 파일 상단에 <code class=\"language-text\">use strict</code>를 선언하면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 코드 2-1</span>\r\n<span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">example1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">example2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n<span class=\"token function\">example1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token function\">example2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>실행 결과</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">  i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\r\n    ^\r\n\r\nReferenceError: i is not defined</code></pre></div>\n<p>var는 함수 스코프이기 때문에 for 반복문에서 정의된 변수가 반복문이 끝난 이후에도 계속 남는 문제점이 발생합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 코드 3 - for 문을 벗어나도 변수가 사라지지 않습니다.</span>\r\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 10</span></code></pre></div>\n<p>실행 결과</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token number\">0</span>\r\n<span class=\"token number\">1</span>\r\n<span class=\"token number\">2</span>\r\n<span class=\"token number\">3</span>\r\n<span class=\"token number\">4</span>\r\n<span class=\"token number\">5</span>\r\n<span class=\"token number\">6</span>\r\n<span class=\"token number\">7</span>\r\n<span class=\"token number\">8</span>\r\n<span class=\"token number\">9</span>\r\n<span class=\"token number\">10</span></code></pre></div>\n<p>for문 뿐만 아니라 while문, switch문, if문 등 모든 코드는 같은 문제를 안고 있습니다.</p>\n<p>이러한 var 변수의 스코프를 제한하기 위해 즉시 실행 함수를 사용하기도 합니다.</p>\n<blockquote>\n<p>즉시 실행 함수<br>\r\n함수를 정의하는 시점에 바로 실행되고 사라집니다.</p>\n</blockquote>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Glossary/IIFE\" target=\"_blank\" rel=\"nofollow\">https://developer.mozilla.org/ko/docs/Glossary/IIFE</a></p>\n<p>var 변수는 함수 스코프이므로 즉시 실행 함수로 묶으면 변수의 스코프를 제한할 수 있지만, 즉시 실행 함수를 작성하기 번거롭고 가독성도 떨어진다는 문제점이 있습니다.</p>\n<h4>var의 문제 2. 호이스팅</h4>\n<blockquote>\n<p>호이스팅(hoisting)<br>\r\n정의된 변수는 그 변수가 속한 스코프의 최상단으로 끌러올려진 것 같은 현상</p>\n</blockquote>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Glossary/Hoisting\" target=\"_blank\" rel=\"nofollow\">https://developer.mozilla.org/ko/docs/Glossary/Hoisting</a></p>\n<p>var로 정의된 변수는 호이스팅이 일어난다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 코드 4 - 변수가 정의된 시점보다 먼저 변수 사용하기</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>myVar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span>\r\n<span class=\"token keyword\">var</span> myVar <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>실행 결과</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">undefined</code></pre></div>\n<p>변수를 정의하기 전에 사용했음에도 이 코드를 실행하면 에러가 발생하지 않으며, 특이한 점은 <code class=\"language-text\">1</code>이 아니라 <code class=\"language-text\">undefined</code>가 출력된다는 점입니다.</p>\n<p>이것은 해당 변수의 정의가 위쪽으로 끌어올려졌기 때문이고, 코드가 <code class=\"language-text\">코드 5</code>처럼 변경됐다고 생각하면 이해하기 쉽습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 코드 5 - 호이스팅의 결과</span>\r\n<span class=\"token keyword\">var</span> myVar <span class=\"token operator\">=</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>myVar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span>\r\nmyVar <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>변수의 정의만 끌어올려지고 값은 원래 정의했던 위치에서 할당됩니다.<br>\r\n특이하게도 <code class=\"language-text\">코드 6</code>처럼 변수가 정의된 곳 위에서 값을 할당할 수도 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 코드 6 - 변수가 정의된 시점보다 먼저 변수에 값을 할당하기</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>myVar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span>\r\nmyVar <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>myVar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 2</span>\r\n<span class=\"token keyword\">var</span> myVar <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>실행 결과</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">undefined\r\n<span class=\"token number\">2</span></code></pre></div>\n<h4>var의 문제 3. 재정의</h4>\n<p>var의 또 다른 문제는 한 번 정의된 변수를 재정의할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> myVar <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">var</span> myVar <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>변수를 정의한다는 것은 이전에 없던 변수를 생성한다는 의미로 통용됩니다.<br>\r\n따라서 위의 코드가 에러 없이 사용될 수 있다는 것은 직관적이지 않으며 버그로 이어질 수 있습니다.<br>\r\n뿐만 아니라, var는 재할당 가능한 변수로만 만들 수밖에 없다는 점입니다.<br>\r\n상수처럼 쓸 값도 무조건 재할당 가능한 변수로 만들어서 사용할 수밖에 없습니다.</p>\n<h3>var의 문제를 해결하는 const, let</h3>\n<h4>const, let은 블록 스코프</h4>\n<p>var는 함수 스코프였지만 const, let은 블록(block) 스코프입니다.<br>\r\n블록 스코프는 대부분의 언어에서 사용하므로 개발자에게 익숙한 개념입니다.<br></p>\n<p><code class=\"language-text\">코드 7</code>와 같이 if문의 블록 안에서 정의된 변수는 if문을 벗어나면 참조할 수 없으며, 사용하려고 하면 에러가 발생합니다.<br></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 코드 7 - 블록 스코프에서는 블록을 벗어나면 변수를 사용할 수 없습니다.</span>\r\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">const</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 참조 에러</span></code></pre></div>\n<p>실행 결과</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">console.log<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // 참조 에러\r\n            ^\r\n\r\nReferenceError: i is not defined</code></pre></div>\n<p>이번에는 블록 스코프에서 같은 이름의 변수를 정의하는 경우를 확인해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 코드 8 - 블록 스코프에서 같은 이름을 갖는 변수의 사용 예시</span>\r\n<span class=\"token keyword\">let</span> foo <span class=\"token operator\">=</span> <span class=\"token string\">'bar1'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// (1)</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// bar1</span>\r\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">let</span> foo <span class=\"token operator\">=</span> <span class=\"token string\">'bar2'</span><span class=\"token punctuation\">;</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// bar2</span>\r\n<span class=\"token punctuation\">}</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>실행 결과</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">bar1\r\nbar2\r\nbar1</code></pre></div>\n<p>마지막 줄의 foo 변수는 같은 블록에서 정의된 변수 (1)를 참조하므로 bar1을 출력합니다.</p>\n<h4>const, let의 호이스팅</h4>\n<p>const와 let으로 정의된 변수 또한, 호이스팅이 됩니다.<br>\r\n하지만, const, let은 변수를 정의하기 전에 사용하려고 하면 참조 에러가 발생합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 코드 9 - const, let 변수는 변수가 정의된 시점보다 먼저 변수를 사용할 수 없습니다.</span>\r\n\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 참조 에러</span>\r\n<span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>실행 결과</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">console.log<span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // 참조 에러\r\n            ^\r\n\r\nReferenceError: Cannot access <span class=\"token string\">'foo'</span> before initialization</code></pre></div>\n<p>실행 결과를 통해 const, let으로 정의된 변수는 호이스팅이 되지 않는다고 생각하지만, const, let으로 정의된 변수도 호이스팅이 일어납니다.<br>\r\n다만, 변수가 정의된 위치와 호이스팅된 위치 사이에서 변수를 사용하려고 하면 에러가 발생하고, 이 구간을 임시적 사각지대(temporal dead zone)라고 부릅니다.<br>\r\nvar로 정의된 변수에는 임시적 사각지대가 없기 때문에 참조 에러가 발생하지 않는 것입니다.</p>\n<h4>const는 변수를 재할당 불가능하게 만듭니다.</h4>\n<p>cons로 정의된 변수는 재할당이 불가능합니다.</p>\n<p>반대로, let, var로 정의된 변수는 재할당할 수 있습니다.</p>\n<p>재할당 불가능한 변수는 프로그램의 복잡도를 상당히 낮춰주기 때문에 되도록이면 재할당이 불가능한 변수를 사용하는게 좋습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 코드 10 - const로 정의된 변수만 재할당 불가능 합니다.</span>\r\n\r\n<span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span>\r\nfoo <span class=\"token operator\">=</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 에러 없음</span>\r\n<span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span>\r\nvalue <span class=\"token operator\">=</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 에러 없음</span>\r\n<span class=\"token keyword\">const</span> bar <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span>\r\nbar <span class=\"token operator\">=</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 에러 발생</span></code></pre></div>\n<p>실행 결과</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">bar <span class=\"token operator\">=</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">;</span> // 에러 발생\r\n    ^\r\n\r\nTypeError: Assignment to constant variable.</code></pre></div>\n<p>다만, const 정의된 객체의 내부 속성값은 수정 가능하다는 점을 주의해야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 코드 11 - const로 정의해도 객체의 내부 속성값은 수정 가능합니다.</span>\r\n<span class=\"token keyword\">const</span> bar <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">prop1</span><span class=\"token operator\">:</span> <span class=\"token string\">'a'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\r\nbar<span class=\"token punctuation\">.</span>prop1 <span class=\"token operator\">=</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">;</span>\r\nbar<span class=\"token punctuation\">.</span>prop2 <span class=\"token operator\">=</span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// { prop1: 'b', prop2: 123 }</span>\r\n<span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\r\narr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\r\narr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">300</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [ 100, 20, 300 ]</span></code></pre></div>\n<p>실행 결과</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token punctuation\">{</span> prop1: <span class=\"token string\">'b'</span>, prop2: <span class=\"token number\">123</span> <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">[</span> <span class=\"token number\">100</span>, <span class=\"token number\">20</span>, <span class=\"token number\">300</span> <span class=\"token punctuation\">]</span></code></pre></div>\n<p>객체의 내부 속성값도 수정 불가능하게 만들고 싶다면 <code class=\"language-text\">immer</code>, <code class=\"language-text\">immutable.js</code> 등의 외부 패키지를 활용하는게 좋습니다.\r\n이러한 외부 패키지는 객체를 수정하려고 할 때, 기존 객체는 변경하지 않고 새로운 객체를 생성합니다.</p>\n<p>새로운 객체를 생성하는 편의 기능은 필요 없고 수정만 할 수 없도록 차단하고 싶다면, 자바스크립트 내장 함수를 이용하면 됩니다.</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions\" target=\"_blank\" rel=\"nofollow\">Object.preventExtensions</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/seal\" target=\"_blank\" rel=\"nofollow\">Object.seal</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\" target=\"_blank\" rel=\"nofollow\">Object.freeze</a></li>\n</ul>","frontmatter":{"title":"자바스크립트의 const, let, var","summary":"conat, let, var","date":"2022.11.05.","categories":["JavaScript"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAcICf/EABcBAAMBAAAAAAAAAAAAAAAAAAQFBgf/2gAMAwEAAhADEAAAAVwwVFK2AP7BM6C9H//EABsQAAICAwEAAAAAAAAAAAAAAAUGAQQCAwcA/9oACAEBAAEFApeB0QXVFcnnZ5grW9m/prxfxcjBE2T9/8QAIREBAAICAQMFAAAAAAAAAAAAAgEDBBESAAUxExQhIiP/2gAIAQMBAT8Br7nOG4vobdwn83NFGNI5GS9KiZn7FcZ3vcbifhT1kd89zfbkX4GI7rnLsfpjbU+Up4bTXltSrLFMuxNpKf/EACIRAAICAgEDBQAAAAAAAAAAAAECAwYEBREAITEHExYkUf/aAAgBAgEBPwHTUneS7HFONLDUZIY8ppcnWWiwXEyl41ihU4NuwTglQjzg8RoUaVZh7ksEBRafckUKnqdtlVeyj41V+APwfQ7AeAPAHAHbr//EACgQAAICAQIFAgcAAAAAAAAAAAIDAQQFERIABhMhMSVRBxAVIyhBRP/aAAgBAQAGPwKfx9o+J09Ns6+P16B59uKHTznKfJFheNW+yizXq1zufUpqXFj/AAnuxspfSlgJEhaTdDEg2R1j+J/JQNKPvGDQjrtkyKXEIZFaxIoKB2rCB0CJ7lJTMKt5yXrGd8CePxWm737UY4rvyb4strY9VNBdCuiF1gdYaK4GupQdmOYW6Rk5ku5T2+X/xAAcEAEAAwACAwAAAAAAAAAAAAABABEhQVFhcZH/2gAIAQEAAT8ha9zMSRIWrZ6O8MpgwJ5ioduwpqJhJdhC/MViqAY0stwVi96bPEIuCEDd4saDQAAdHwn/2gAMAwEAAgADAAAAELPv/8QAFhEBAQEAAAAAAAAAAAAAAAAAAREA/9oACAEDAQE/EIf7M+uPaABcQFJhwwQ0y0usL1//xAAYEQEBAAMAAAAAAAAAAAAAAAABEQAhMf/aAAgBAgEBPxBXcPKFEeaaGBmNKFRcNcWmxRAD/8QAGRABAQEAAwAAAAAAAAAAAAAAAREAMXGB/9oACAEBAAE/EDuadKW7IgBBigJroVNZ5BUv3IbjApDnEywgGSiDESsFmoBVYVTP5ZBDnv8AAr06EJxj5db/2Q=="},"images":{"fallback":{"src":"/static/4866468dc1fc17a8ad9fb75dd0fa2e3b/7002e/javascript-var-let-const.jpg","srcSet":"/static/4866468dc1fc17a8ad9fb75dd0fa2e3b/e8044/javascript-var-let-const.jpg 400w,\n/static/4866468dc1fc17a8ad9fb75dd0fa2e3b/a09fe/javascript-var-let-const.jpg 800w,\n/static/4866468dc1fc17a8ad9fb75dd0fa2e3b/7002e/javascript-var-let-const.jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"},"sources":[{"srcSet":"/static/4866468dc1fc17a8ad9fb75dd0fa2e3b/a29e4/javascript-var-let-const.webp 400w,\n/static/4866468dc1fc17a8ad9fb75dd0fa2e3b/64466/javascript-var-let-const.webp 800w,\n/static/4866468dc1fc17a8ad9fb75dd0fa2e3b/e0e60/javascript-var-let-const.webp 1600w","type":"image/webp","sizes":"(min-width: 1600px) 1600px, 100vw"}]},"width":1600,"height":900}},"publicURL":"/static/4866468dc1fc17a8ad9fb75dd0fa2e3b/javascript-var-let-const.jpeg"}}}}]}},"pageContext":{"slug":"/JavaScript/const_let_var/"}},
    "staticQueryHashes": []}